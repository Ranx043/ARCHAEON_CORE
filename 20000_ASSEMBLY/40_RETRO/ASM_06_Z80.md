# ASM_06: Zilog Z80

> "El Z80 dominó la era de 8 bits. CP/M, Spectrum, Game Boy - todos hablaban Z80."

---

## Historia

```
1976: Z80 lanzado (compatible con 8080)
1977: TRS-80
1979: ZX80, luego ZX81
1982: ZX Spectrum, MSX
1985: Amstrad CPC
1989: Game Boy (Sharp LR35902)
1990s: Aún en calculadoras TI
```

### Dónde Encontrar Z80

| Sistema | Año | Clock |
|---------|-----|-------|
| TRS-80 | 1977 | 1.77 MHz |
| ZX Spectrum | 1982 | 3.5 MHz |
| MSX | 1983 | 3.58 MHz |
| Amstrad CPC | 1984 | 4 MHz |
| Sega Master System | 1985 | 3.58 MHz |
| Game Boy | 1989 | 4.19 MHz (variante) |

---

## Registros

### Registros Principales

```
┌─────────────────────────────────────────────────────┐
│                    Registros Z80                     │
├─────────────┬─────────────┬─────────────────────────┤
│ 16-bit      │   8-bit     │ Uso                     │
├─────────────┼─────────────┼─────────────────────────┤
│     AF      │   A    F    │ Accumulator + Flags     │
│     BC      │   B    C    │ Contador / Propósito gen│
│     DE      │   D    E    │ Destino / Propósito gen │
│     HL      │   H    L    │ Puntero / Propósito gen │
├─────────────┼─────────────┼─────────────────────────┤
│     AF'     │   A'   F'   │ Alternate set           │
│     BC'     │   B'   C'   │ Alternate set           │
│     DE'     │   D'   E'   │ Alternate set           │
│     HL'     │   H'   L'   │ Alternate set           │
├─────────────┼─────────────┼─────────────────────────┤
│     IX      │   IXH  IXL  │ Index Register X        │
│     IY      │   IYH  IYL  │ Index Register Y        │
├─────────────┼─────────────┼─────────────────────────┤
│     SP      │    -    -   │ Stack Pointer           │
│     PC      │    -    -   │ Program Counter         │
├─────────────┼─────────────┼─────────────────────────┤
│      I      │      -      │ Interrupt Vector        │
│      R      │      -      │ Memory Refresh          │
└─────────────┴─────────────┴─────────────────────────┘
```

### Registro de Flags (F)

```
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ S │ Z │ - │ H │ - │P/V│ N │ C │
└───┴───┴───┴───┴───┴───┴───┴───┘
  7   6   5   4   3   2   1   0

S: Sign       - Bit 7 del resultado
Z: Zero       - Resultado cero
H: Half Carry - Acarreo del bit 3
P/V: Parity/Overflow
N: Add/Subtract - Última operación fue resta
C: Carry      - Acarreo
```

### Alternate Registers

El Z80 tiene un conjunto alternativo de registros (AF', BC', DE', HL').
Se intercambian con `EX AF, AF'` y `EXX`.

```asm
EX AF, AF'     ; Swap AF con AF'
EXX            ; Swap BC,DE,HL con BC',DE',HL'
```

---

## Instrucciones

### Load 8-bit

```asm
LD A, $42      ; A = $42 (inmediato)
LD A, B        ; A = B (registro)
LD A, (HL)     ; A = mem[HL]
LD A, ($1234)  ; A = mem[$1234]
LD A, (IX+$04) ; A = mem[IX+4]
LD (HL), A     ; mem[HL] = A
LD (HL), $42   ; mem[HL] = $42
```

### Load 16-bit

```asm
LD HL, $1234   ; HL = $1234
LD BC, $1234   ; BC = $1234
LD DE, $1234   ; DE = $1234
LD SP, $1234   ; SP = $1234
LD IX, $1234   ; IX = $1234
LD HL, ($1234) ; HL = mem16[$1234]
LD ($1234), HL ; mem16[$1234] = HL
LD SP, HL      ; SP = HL
```

### Aritmética 8-bit

```asm
; Suma
ADD A, B       ; A = A + B
ADD A, $42     ; A = A + $42
ADD A, (HL)    ; A = A + mem[HL]
ADC A, B       ; A = A + B + Carry

; Resta
SUB B          ; A = A - B
SUB $42        ; A = A - $42
SBC A, B       ; A = A - B - Carry

; Incremento/Decremento
INC A          ; A++
INC B          ; B++
DEC A          ; A--
INC (HL)       ; mem[HL]++
```

### Aritmética 16-bit

```asm
ADD HL, BC     ; HL = HL + BC
ADD HL, DE     ; HL = HL + DE
ADD IX, BC     ; IX = IX + BC
ADC HL, BC     ; HL = HL + BC + Carry
SBC HL, BC     ; HL = HL - BC - Carry
INC HL         ; HL++
DEC HL         ; HL--
INC BC         ; BC++
```

### Lógica

```asm
AND B          ; A = A & B
AND $42        ; A = A & $42
OR B           ; A = A | B
XOR B          ; A = A ^ B
CPL            ; A = ~A (complement)
NEG            ; A = -A (negate)
```

### Comparación

```asm
CP B           ; Compara A con B (A - B, sin guardar)
CP $42         ; Compara A con $42
CP (HL)        ; Compara A con mem[HL]

; Después de CP:
; Z = 1 si A == operando
; C = 1 si A < operando
; S = signo de A - operando
```

### Shifts y Rotaciones

```asm
; Rotaciones (8-bit ring)
RLCA           ; Rotate Left Circular A
RRCA           ; Rotate Right Circular A
RLA            ; Rotate Left through Carry
RRA            ; Rotate Right through Carry

; Shifts
SLA B          ; Shift Left Arithmetic
SRA B          ; Shift Right Arithmetic (preserva signo)
SRL B          ; Shift Right Logical (0 entra)

; Rotate de memoria
RL (HL)        ; Rotate left mem[HL]
RR (HL)        ; Rotate right mem[HL]
```

### Bit Operations

```asm
BIT 3, A       ; Test bit 3 de A (Z = !bit3)
SET 3, A       ; Set bit 3 de A
RES 3, A       ; Reset bit 3 de A
BIT 7, (HL)    ; Test bit 7 de mem[HL]
```

### Jumps

```asm
JP $1234       ; Jump absoluto
JP (HL)        ; Jump a dirección en HL
JP NZ, $1234   ; Jump if Not Zero
JP Z, $1234    ; Jump if Zero
JP NC, $1234   ; Jump if No Carry
JP C, $1234    ; Jump if Carry
JP PO, $1234   ; Jump if Parity Odd
JP PE, $1234   ; Jump if Parity Even
JP P, $1234    ; Jump if Positive
JP M, $1234    ; Jump if Minus

JR $10         ; Jump Relative (+/- 127)
JR NZ, $10     ; Jump Relative if Not Zero
JR Z, $10      ; Jump Relative if Zero
JR NC, $10     ; Jump Relative if No Carry
JR C, $10      ; Jump Relative if Carry

DJNZ $10       ; Decrement B, Jump if Not Zero
               ; Loop muy eficiente!
```

### Subrutinas

```asm
CALL $1234     ; Push PC, jump to $1234
CALL NZ, $1234 ; Call condicional
RET            ; Pop PC, return
RET NZ         ; Return condicional
```

### Stack

```asm
PUSH AF        ; Push AF
PUSH BC        ; Push BC
PUSH DE        ; Push DE
PUSH HL        ; Push HL
POP AF         ; Pop AF
POP BC         ; Pop BC
```

### Exchange

```asm
EX DE, HL      ; Swap DE y HL
EX (SP), HL    ; Swap HL con top of stack
EX AF, AF'     ; Swap AF con alternate
EXX            ; Swap BC,DE,HL con alternates
```

### Block Operations

```asm
; Load Block
LDI            ; Load (DE) from (HL), inc HL,DE, dec BC
LDIR           ; LDI repeat until BC=0 (copy block!)
LDD            ; Como LDI pero decrementa
LDDR           ; LDD repeat

; Compare Block
CPI            ; Compare A with (HL), inc HL, dec BC
CPIR           ; CPI repeat until match or BC=0
CPD            ; Como CPI pero decrementa
CPDR           ; CPD repeat

; I/O Block
INI            ; Input (HL) from port C
INIR           ; INI repeat
OUTI           ; Output (HL) to port C
OTIR           ; OUTI repeat
```

---

## Patrones Comunes

### Copy Block

```asm
        LD HL, source
        LD DE, dest
        LD BC, length
        LDIR           ; Copia BC bytes de HL a DE
```

### Clear Memory

```asm
        LD HL, buffer
        LD DE, buffer+1
        LD BC, length-1
        LD (HL), 0     ; Primer byte = 0
        LDIR           ; Propaga el 0
```

### Loop con DJNZ

```asm
        LD B, 10       ; 10 iteraciones
loop:
        ; ... código ...
        DJNZ loop      ; B--, if B!=0 goto loop
```

### Search Byte

```asm
        LD HL, buffer
        LD BC, length
        LD A, $42      ; Byte a buscar
        CPIR           ; Buscar
        JR Z, found    ; Si Z, encontrado en HL-1
not_found:
        ; ...
found:
        DEC HL         ; HL apunta al byte
```

### Suma 16-bit

```asm
        LD HL, (num1)
        LD DE, (num2)
        ADD HL, DE
        LD (result), HL
```

### Multiplicar por constante

```asm
; A * 10 = A*8 + A*2
        LD B, A        ; B = A
        ADD A, A       ; A = A*2
        ADD A, A       ; A = A*4
        ADD A, A       ; A = A*8
        ADD A, B       ; A = A*8 + A
        ADD A, B       ; A = A*8 + A*2 = A*10
```

---

## Ejemplo: Hello World (ZX Spectrum)

```asm
        ORG $8000

start:
        LD HL, message
loop:
        LD A, (HL)
        OR A           ; Test if zero
        RET Z          ; Return if end
        RST $10        ; Print char (ROM routine)
        INC HL
        JR loop

message:
        DEFM "Hello, Z80!"
        DEFB 13        ; Newline
        DEFB 0         ; Terminator
```

---

## Comparación con 8080

| Característica | 8080 | Z80 |
|----------------|------|-----|
| Registros | A,B,C,D,E,H,L | + IX,IY,AF',BC',DE',HL' |
| Instrucciones | 78 | 158 |
| Addressing | Básico | + (IX+d), (IY+d) |
| Block ops | No | LDIR, CPIR, etc. |
| Bit ops | No | BIT, SET, RES |
| Relative jumps | No | JR, DJNZ |

---

## Próximo Documento

- **ASM_07_68000.md**: Motorola 68000

---

*"El Z80 fue el Intel x86 de los 80s: ubicuo, capaz, y lleno de trucos."*

