# ASM_07: Motorola 68000

> "El 68000 era un mainframe en un chip. Elegante, poderoso, y adelantado a su tiempo."

---

## Historia

```
1979: MC68000 lanzado
1984: Macintosh (8 MHz)
1985: Atari ST, Amiga 1000
1988: Sega Genesis/Mega Drive
1994: 68060 (última generación)
```

### Dónde Encontrar 68000

| Sistema | Año | Clock |
|---------|-----|-------|
| Apple Lisa | 1983 | 5 MHz |
| Macintosh | 1984 | 8 MHz |
| Atari ST | 1985 | 8 MHz |
| Amiga 500 | 1987 | 7.14 MHz |
| Sega Genesis | 1988 | 7.6 MHz |
| TI-89 Calculator | 1998 | 10 MHz |

---

## Arquitectura

### Características

- 32-bit interno, 16-bit bus de datos
- 24-bit address bus (16 MB)
- 8 registros de datos (D0-D7)
- 8 registros de direcciones (A0-A7)
- Ortogonal: casi cualquier operación con cualquier modo
- Big endian

### Registros

```
┌──────────────────────────────────────────────────────┐
│                  Registros 68000                      │
├─────────────┬────────────────────────────────────────┤
│    D0       │  Data Register 0 (32-bit)              │
│    D1       │  Data Register 1                       │
│    D2       │  Data Register 2                       │
│    D3       │  Data Register 3                       │
│    D4       │  Data Register 4                       │
│    D5       │  Data Register 5                       │
│    D6       │  Data Register 6                       │
│    D7       │  Data Register 7                       │
├─────────────┼────────────────────────────────────────┤
│    A0       │  Address Register 0 (32-bit)           │
│    A1       │  Address Register 1                    │
│    A2       │  Address Register 2                    │
│    A3       │  Address Register 3                    │
│    A4       │  Address Register 4                    │
│    A5       │  Address Register 5                    │
│    A6       │  Frame Pointer (por convención)        │
│    A7/SP    │  Stack Pointer                         │
├─────────────┼────────────────────────────────────────┤
│    PC       │  Program Counter (32-bit)              │
│    SR       │  Status Register (16-bit)              │
│    USP      │  User Stack Pointer                    │
│    SSP      │  Supervisor Stack Pointer              │
└─────────────┴────────────────────────────────────────┘
```

### Status Register

```
┌─────────────────────────────────────────────────────────┐
│  15  14  13  12  11  10   9   8   7 ...  4   3   2   1   0 │
├────┬────┬────┬────┬────┬────┬────┬────┬────────────────────┤
│ T1 │ T0 │ S  │ M  │  0 │ I2 │ I1 │ I0 │    X  N  Z  V  C   │
└────┴────┴────┴────┴────┴────┴────┴────┴────────────────────┘

Condition Codes (CCR):
  X: Extend      - Copia de Carry para operaciones extendidas
  N: Negative    - Resultado negativo
  Z: Zero        - Resultado cero
  V: Overflow    - Overflow con signo
  C: Carry       - Acarreo

System byte:
  T: Trace       - Modo trace (debugging)
  S: Supervisor  - Modo supervisor (kernel)
  I: Interrupt   - Máscara de interrupciones (0-7)
```

---

## Tamaños de Operandos

El 68000 soporta tres tamaños, indicados con sufijo:

| Sufijo | Tamaño | Bits |
|--------|--------|------|
| .B | Byte | 8 |
| .W | Word | 16 |
| .L | Long | 32 |

```asm
MOVE.B D0, D1      ; Copia byte
MOVE.W D0, D1      ; Copia word
MOVE.L D0, D1      ; Copia long
ADD.L  D0, D1      ; Suma 32-bit
```

---

## Modos de Direccionamiento

| Modo | Sintaxis | Ejemplo | Descripción |
|------|----------|---------|-------------|
| Data Register | Dn | D0 | Registro de datos |
| Address Register | An | A0 | Registro de direcciones |
| Address Indirect | (An) | (A0) | Memoria en dirección An |
| Post-increment | (An)+ | (A0)+ | An++, luego usa An |
| Pre-decrement | -(An) | -(A0) | --An, luego usa An |
| Displacement | d(An) | 8(A0) | An + desplazamiento |
| Indexed | d(An,Xn) | 4(A0,D0) | An + Xn + desplazamiento |
| Absolute Short | xxx.W | $1234.W | Dirección 16-bit |
| Absolute Long | xxx.L | $12345678.L | Dirección 32-bit |
| PC Relative | d(PC) | label(PC) | PC + desplazamiento |
| PC Indexed | d(PC,Xn) | label(PC,D0) | PC + Xn + desplazamiento |
| Immediate | #xxx | #$1234 | Valor inmediato |

### Visualización de Modos

```asm
; Data Register Direct
MOVE.L D0, D1          ; D1 = D0

; Address Register Indirect
MOVE.L (A0), D0        ; D0 = mem[A0]

; Post-increment (para arrays, strings)
MOVE.B (A0)+, D0       ; D0 = mem[A0]; A0++

; Pre-decrement (para stack)
MOVE.L D0, -(A7)       ; A7--; mem[A7] = D0 (PUSH)
MOVE.L (A7)+, D0       ; D0 = mem[A7]; A7++ (POP)

; Displacement (structs)
MOVE.L 8(A0), D0       ; D0 = mem[A0 + 8]

; Indexed (arrays)
MOVE.L 0(A0,D1.W), D0  ; D0 = mem[A0 + D1]
```

---

## Instrucciones

### Move

```asm
MOVE.L D0, D1          ; D1 = D0
MOVE.L #$1234, D0      ; D0 = $1234
MOVE.L (A0), D0        ; D0 = mem[A0]
MOVE.L D0, (A0)        ; mem[A0] = D0
MOVEA.L A0, A1         ; A1 = A0 (address move)
MOVEQ  #42, D0         ; D0 = 42 (quick, -128 a 127)

; Move Multiple (save/restore registros)
MOVEM.L D0-D7/A0-A6, -(A7)  ; Push todos
MOVEM.L (A7)+, D0-D7/A0-A6  ; Pop todos
```

### Aritmética

```asm
; Suma
ADD.L  D0, D1          ; D1 = D1 + D0
ADD.L  #100, D0        ; D0 = D0 + 100
ADDA.L D0, A0          ; A0 = A0 + D0 (address add)
ADDQ.L #8, A0          ; A0 += 8 (quick, 1-8)
ADDI.L #$1234, D0      ; D0 += $1234 (immediate)
ADDX.L D0, D1          ; D1 = D1 + D0 + X

; Resta
SUB.L  D0, D1          ; D1 = D1 - D0
SUBA.L D0, A0          ; A0 = A0 - D0
SUBQ.L #4, A0          ; A0 -= 4
SUBX.L D0, D1          ; D1 = D1 - D0 - X

; Multiplicación
MULU.W D0, D1          ; D1 = D1.W * D0.W (unsigned, 32-bit result)
MULS.W D0, D1          ; D1 = D1.W * D0.W (signed)

; División
DIVU.W D0, D1          ; D1.L / D0.W → D1 = quotient:remainder
DIVS.W D0, D1          ; Signed division

; Negación
NEG.L  D0              ; D0 = -D0
NEGX.L D0              ; D0 = -D0 - X

; Clear
CLR.L  D0              ; D0 = 0
CLR.L  (A0)            ; mem[A0] = 0
```

### Lógica

```asm
AND.L  D0, D1          ; D1 = D1 & D0
AND.L  #$FF, D0        ; D0 = D0 & $FF
OR.L   D0, D1          ; D1 = D1 | D0
EOR.L  D0, D1          ; D1 = D1 ^ D0
NOT.L  D0              ; D0 = ~D0
```

### Shifts y Rotaciones

```asm
; Shifts
LSL.L  #4, D0          ; D0 <<= 4 (logical left)
LSR.L  #4, D0          ; D0 >>= 4 (logical right)
ASL.L  D1, D0          ; D0 <<= D1 (arithmetic left)
ASR.L  #4, D0          ; D0 >>= 4 (arithmetic right, sign extend)

; Rotaciones
ROL.L  #4, D0          ; Rotate left
ROR.L  #4, D0          ; Rotate right
ROXL.L #1, D0          ; Rotate left through X
ROXR.L #1, D0          ; Rotate right through X
```

### Comparación

```asm
CMP.L  D0, D1          ; Compare D1 - D0, set flags
CMP.L  #100, D0        ; Compare D0 - 100
CMPA.L A0, A1          ; Compare addresses
CMPI.L #$1234, D0      ; Compare immediate
TST.L  D0              ; Test D0 (compare with 0)
```

### Branches

```asm
BRA    label           ; Branch Always
BEQ    label           ; Branch if Equal (Z=1)
BNE    label           ; Branch if Not Equal (Z=0)
BGT    label           ; Branch if Greater Than (signed)
BGE    label           ; Branch if Greater or Equal (signed)
BLT    label           ; Branch if Less Than (signed)
BLE    label           ; Branch if Less or Equal (signed)
BHI    label           ; Branch if Higher (unsigned)
BHS/BCC label          ; Branch if Higher or Same (unsigned)
BLO/BCS label          ; Branch if Lower (unsigned)
BLS    label           ; Branch if Lower or Same (unsigned)
BPL    label           ; Branch if Plus (N=0)
BMI    label           ; Branch if Minus (N=1)
BVC    label           ; Branch if Overflow Clear
BVS    label           ; Branch if Overflow Set

; Decrement and Branch
DBF    D0, label       ; D0--; if D0 != -1 goto label
DBRA   D0, label       ; Alias para DBF (loop)
```

### Jumps y Subrutinas

```asm
JMP    label           ; Jump absoluto
JMP    (A0)            ; Jump indirecto

JSR    label           ; Jump to Subroutine
JSR    (A0)            ; JSR indirecto

BSR    label           ; Branch to Subroutine (relativo)

RTS                    ; Return from Subroutine
RTE                    ; Return from Exception
```

### Stack

```asm
; El stack usa A7 con pre-decrement/post-increment
MOVE.L D0, -(A7)       ; PUSH
MOVE.L (A7)+, D0       ; POP

; Link/Unlink para stack frames
LINK   A6, #-8         ; Push A6, A6=SP, SP-=8
UNLK   A6              ; SP=A6, Pop A6
```

### Set Condicional

```asm
SEQ    D0              ; D0.B = (Z==1) ? $FF : $00
SNE    D0              ; D0.B = (Z==0) ? $FF : $00
SGT    D0              ; etc.
```

### Bit Operations

```asm
BTST   #7, D0          ; Test bit 7 of D0
BSET   #7, D0          ; Set bit 7
BCLR   #7, D0          ; Clear bit 7
BCHG   #7, D0          ; Toggle bit 7

BTST   D1, D0          ; Test bit D1 of D0
```

---

## Patrones Comunes

### Copy Block

```asm
        LEA    source, A0
        LEA    dest, A1
        MOVE.L #count-1, D0
loop:
        MOVE.B (A0)+, (A1)+
        DBRA   D0, loop
```

### Loop con DBRA

```asm
        MOVE.W #9, D0      ; 10 iteraciones (0-9)
loop:
        ; ... código ...
        DBRA   D0, loop    ; D0--, if D0 != -1 goto loop
```

### Stack Frame

```asm
function:
        LINK   A6, #-8     ; Crear frame, 8 bytes locales
        MOVEM.L D2-D5, -(A7)  ; Guardar registros

        ; Acceder a parámetros: 8(A6), 12(A6), ...
        ; Acceder a locales: -4(A6), -8(A6), ...

        MOVEM.L (A7)+, D2-D5  ; Restaurar
        UNLK   A6          ; Destruir frame
        RTS
```

### String Length

```asm
strlen:
        MOVE.L A0, D0      ; Guardar inicio
loop:
        TST.B  (A0)+       ; Test byte, avanzar
        BNE    loop        ; Mientras no sea 0
        SUBA.L D0, A0      ; A0 - inicio
        MOVE.L A0, D0      ; Resultado
        SUBQ.L #1, D0      ; -1 por el null
        RTS
```

---

## Ejemplo: Hello World (Amiga)

```asm
        SECTION code,CODE

start:
        MOVE.L  4.W, A6         ; ExecBase
        LEA     dosname(PC), A1 ; "dos.library"
        MOVEQ   #0, D0
        JSR     -552(A6)        ; OpenLibrary
        MOVE.L  D0, A6          ; DosBase
        BEQ     exit

        MOVE.L  #message, D1
        JSR     -948(A6)        ; PutStr

exit:
        MOVEQ   #0, D0
        RTS

dosname:
        DC.B    "dos.library",0

message:
        DC.B    "Hello, 68000!",10,0
```

---

## Comparación con otras arquitecturas

| Característica | 68000 | 8086 | 6502 |
|----------------|-------|------|------|
| Registros | 16 (D0-D7, A0-A7) | 8 | 3 |
| GPR de 32-bit | 16 | 0 | 0 |
| Modos direccionamiento | 14 | 7 | 13 |
| Ortogonalidad | Alta | Baja | Media |
| Endianness | Big | Little | Little |
| Código limpio | Muy limpio | Irregular | Compacto |

---

## Próximo Documento

- **ASM_08_PRACTICA.md**: Ejercicios prácticos multi-arquitectura

---

*"El 68000 fue diseñado por ingenieros que querían programar, no sufrir."*

