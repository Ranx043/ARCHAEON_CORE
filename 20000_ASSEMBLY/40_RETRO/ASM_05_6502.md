# ASM_05: MOS 6502

> "Con solo 56 instrucciones, el 6502 construyó la revolución de las computadoras personales."

---

## Historia

```
1975: MOS 6502 lanzado ($25, vs $300 del 6800)
1977: Apple II, Commodore PET, Atari 2600
1982: Commodore 64
1983: Nintendo Famicom/NES
1985: WDC 65C02 (versión CMOS)
1990: WDC 65816 (16-bit, SNES)
```

### Dónde Vive el 6502

| Sistema | Año | Notas |
|---------|-----|-------|
| Apple I, II | 1976-77 | 1 MHz |
| Commodore PET, VIC-20, C64 | 1977-82 | |
| Atari 2600, 400/800 | 1977-79 | |
| NES/Famicom | 1983 | 2A03 (6502 custom) |
| BBC Micro | 1981 | Usado en escuelas UK |

---

## Arquitectura

### Características

- 8-bit data bus
- 16-bit address bus (64KB máximo)
- 56 instrucciones
- 13 modos de direccionamiento
- Clock: 1-2 MHz típico
- Little endian

### Registros

```
┌─────────────────────────────────────────┐
│              Registros 6502              │
├─────────────┬───────────────────────────┤
│      A      │ Accumulator (8-bit)       │
├─────────────┼───────────────────────────┤
│      X      │ Index Register X (8-bit)  │
├─────────────┼───────────────────────────┤
│      Y      │ Index Register Y (8-bit)  │
├─────────────┼───────────────────────────┤
│      S      │ Stack Pointer (8-bit)     │
│             │ Stack en $0100-$01FF      │
├─────────────┼───────────────────────────┤
│     PC      │ Program Counter (16-bit)  │
├─────────────┼───────────────────────────┤
│      P      │ Processor Status (8-bit)  │
└─────────────┴───────────────────────────┘
```

### Registro de Estado (P)

```
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ N │ V │ - │ B │ D │ I │ Z │ C │
└───┴───┴───┴───┴───┴───┴───┴───┘
  7   6   5   4   3   2   1   0

N: Negative    - Bit 7 del resultado
V: Overflow    - Overflow con signo
-: (unused)    - Siempre 1
B: Break       - BRK fue ejecutado
D: Decimal     - Modo BCD
I: Interrupt   - Deshabilitar IRQ
Z: Zero        - Resultado fue cero
C: Carry       - Acarreo/borrow
```

---

## Mapa de Memoria

```
$FFFF ┌────────────────────┐
      │                    │
      │   ROM/Cartridge    │  Programa, datos
      │                    │
$8000 ├────────────────────┤
      │                    │
      │   RAM / I/O        │  Varía por sistema
      │                    │
$0200 ├────────────────────┤
      │      Stack         │  $0100-$01FF
$0100 ├────────────────────┤
      │   Zero Page        │  $0000-$00FF
$0000 └────────────────────┘

Zero Page: Acceso rápido (direccionamiento de 1 byte)
Stack: 256 bytes, crece hacia abajo
```

---

## Modos de Direccionamiento

| Modo | Sintaxis | Ejemplo | Bytes | Descripción |
|------|----------|---------|-------|-------------|
| Implied | - | `TAX` | 1 | Operación implícita |
| Accumulator | A | `ASL A` | 1 | Opera en A |
| Immediate | #$nn | `LDA #$42` | 2 | Valor inmediato |
| Zero Page | $nn | `LDA $42` | 2 | Dirección 0-255 |
| Zero Page,X | $nn,X | `LDA $42,X` | 2 | ZP + X |
| Zero Page,Y | $nn,Y | `LDX $42,Y` | 2 | ZP + Y |
| Absolute | $nnnn | `LDA $1234` | 3 | Dirección completa |
| Absolute,X | $nnnn,X | `LDA $1234,X` | 3 | Abs + X |
| Absolute,Y | $nnnn,Y | `LDA $1234,Y` | 3 | Abs + Y |
| Indirect | ($nnnn) | `JMP ($1234)` | 3 | Puntero |
| (Indirect,X) | ($nn,X) | `LDA ($20,X)` | 2 | Puntero en ZP+X |
| (Indirect),Y | ($nn),Y | `LDA ($20),Y` | 2 | Puntero en ZP, +Y |
| Relative | $nn | `BEQ $10` | 2 | Branch offset (-128 a +127) |

### Visualización de Indirect Modes

```
(Indirect,X) - Indexed Indirect:
  LDA ($20,X)  ; X = 4

  1. Suma: $20 + $04 = $24
  2. Lee puntero de $24,$25
  3. Si $24,$25 = $00,$80 → lee de $8000

(Indirect),Y - Indirect Indexed:
  LDA ($20),Y  ; Y = 4

  1. Lee puntero de $20,$21
  2. Si $20,$21 = $00,$80
  3. Suma Y: $8000 + $04 = $8004
  4. Lee de $8004
```

---

## Instrucciones

### Load/Store

```asm
; Load
LDA #$42       ; A = $42
LDA $20        ; A = mem[$20]
LDA $1234      ; A = mem[$1234]
LDX #$10       ; X = $10
LDY #$20       ; Y = $20

; Store
STA $20        ; mem[$20] = A
STA $1234      ; mem[$1234] = A
STX $20        ; mem[$20] = X
STY $20        ; mem[$20] = Y
```

### Transfer

```asm
TAX            ; X = A
TAY            ; Y = A
TXA            ; A = X
TYA            ; A = Y
TSX            ; X = S (stack pointer)
TXS            ; S = X
```

### Aritmética

```asm
; Suma (con carry)
CLC            ; Clear carry primero
ADC #$42       ; A = A + $42 + C
ADC $20        ; A = A + mem[$20] + C

; Resta (con borrow)
SEC            ; Set carry (no borrow)
SBC #$42       ; A = A - $42 - !C
SBC $20        ; A = A - mem[$20] - !C

; Para sumar 16-bit:
CLC
LDA LOW
ADC #$34       ; Suma byte bajo
STA LOW
LDA HIGH
ADC #$12       ; Suma byte alto + carry
STA HIGH
```

### Incremento/Decremento

```asm
INX            ; X++
INY            ; Y++
DEX            ; X--
DEY            ; Y--
INC $20        ; mem[$20]++
DEC $20        ; mem[$20]--
```

### Lógica

```asm
AND #$0F       ; A = A & $0F
ORA #$80       ; A = A | $80
EOR #$FF       ; A = A ^ $FF (NOT)

; BIT test
BIT $20        ; N = bit7, V = bit6, Z = A & mem
```

### Shifts

```asm
ASL A          ; A <<= 1, C = bit7
LSR A          ; A >>= 1, C = bit0
ROL A          ; Rotate left through carry
ROR A          ; Rotate right through carry

; También en memoria
ASL $20        ; mem[$20] <<= 1
```

### Comparación

```asm
CMP #$42       ; Compare A with $42
CMP $20        ; Compare A with mem[$20]
CPX #$10       ; Compare X
CPY #$10       ; Compare Y

; Después de CMP:
; Z = 1 si A == operando
; C = 1 si A >= operando
; N = bit 7 de (A - operando)
```

### Branches

```asm
BEQ label      ; Branch if Equal (Z=1)
BNE label      ; Branch if Not Equal (Z=0)
BCC label      ; Branch if Carry Clear (C=0)
BCS label      ; Branch if Carry Set (C=1)
BPL label      ; Branch if Plus (N=0)
BMI label      ; Branch if Minus (N=1)
BVC label      ; Branch if Overflow Clear (V=0)
BVS label      ; Branch if Overflow Set (V=1)
```

### Jumps y Subrutinas

```asm
JMP $1234      ; Jump to address
JMP ($1234)    ; Jump indirect

JSR $1234      ; Jump to Subroutine
               ; Push PC+2, jump to address

RTS            ; Return from Subroutine
               ; Pop PC, jump to PC+1

RTI            ; Return from Interrupt
               ; Pop P, pop PC
```

### Stack

```asm
PHA            ; Push A
PLA            ; Pull A
PHP            ; Push P (status)
PLP            ; Pull P
```

### Flags

```asm
CLC            ; Clear Carry
SEC            ; Set Carry
CLI            ; Clear Interrupt disable
SEI            ; Set Interrupt disable
CLD            ; Clear Decimal mode
SED            ; Set Decimal mode
CLV            ; Clear Overflow
```

---

## Patrones Comunes

### Loop Contador

```asm
        LDX #$0A       ; contador = 10
loop:
        ; ... código ...
        DEX            ; contador--
        BNE loop       ; while (contador != 0)
```

### Copiar Bloque

```asm
        LDX #$00       ; índice = 0
copy:
        LDA source,X   ; leer source[X]
        STA dest,X     ; escribir dest[X]
        INX
        CPX #$80       ; hasta 128 bytes
        BNE copy
```

### Suma 16-bit

```asm
; result = value1 + value2 (16-bit)
        CLC
        LDA value1_lo
        ADC value2_lo
        STA result_lo
        LDA value1_hi
        ADC value2_hi
        STA result_hi
```

### Multiplicar por 2

```asm
        ASL A          ; A *= 2

; Para 16-bit:
        ASL low
        ROL high       ; Carry del ASL entra
```

### Dividir por 2

```asm
        LSR A          ; A /= 2 (unsigned)

; Para 16-bit:
        LSR high
        ROR low        ; Carry del LSR entra
```

---

## Ejemplo: Hello World (C64)

```asm
        * = $0801      ; BASIC start

        ; BASIC line: 10 SYS 2064
        .byte $0B,$08,$0A,$00,$9E,$32,$30,$36,$34,$00,$00,$00

        * = $0810      ; Código empieza aquí

start:
        LDX #$00
loop:
        LDA message,X
        BEQ done       ; Si es 0, terminar
        JSR $FFD2      ; CHROUT (print char)
        INX
        BNE loop
done:
        RTS

message:
        .text "HELLO, 6502!"
        .byte $0D, $00  ; newline, null
```

---

## Próximo Documento

- **ASM_05_Z80.md**: Zilog Z80

---

*"El 6502 demostró que puedes cambiar el mundo con 3,500 transistores."*

